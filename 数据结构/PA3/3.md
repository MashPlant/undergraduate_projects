0. 题目描述
   
   给出一组初始的从$unsigned$到$string$的映射，给出$n$次操作，每次操作查询一个键映射到的值或者插入一对新的映射

1. 所使用数据结构与算法的构思、原理和实现要点

    采用散列表解决

    对于初始密码表，暴力地枚举所有长度$\le 5$的密码，加盐后计算$crc32$值后插入散列表

    对于后续的弱密码，同样加盐后计算$crc32$值后插入散列表

    散列表采用闭散列来解决冲突，探查方法为朴素的线性探测，探查序列是连续的一段，缓存友好，因此这样做的常数很有可能比其它方法要优秀

    考虑到散列表的最大键数确定，可以提前开好所有空间。设提前开好大小为$U=2^P$的数组，则散列函数选择为
    ```
    h = k & (U - 1)
    ```
    非常暴力，而且似乎犯了对2的幂次取模的禁忌。但是实际上效果还行，这可能是因为crc32函数本身就是一个散列函数，很难通过刻意构造字符串来控制函数值的输出，因此也没办法很容易的构造数据来卡这个取模。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题

    我发现crc32函数的计算占据了代码大部分的运行时间，于是把crc32库中的数组复制到我的程序中，从而可以incremental地计算crc32值，而不是每次都要调用函数来遍历整个字符串。
   
3. 时间和空间复杂度的估算
   
   长度$\le 5$的密码共有$18 + 18 ^ 2 + 18 ^ 3 + 18 ^ 4 + 18 ^ 5=2000718$

   所有散列表操作期望时间复杂度均为$O(1)$，从而总时间复杂度为$O(n+2000718)=O(n)$
    
   散列表的$U$可选择为$n$的常数倍，从而空间复杂度也是$O(n)$

4. 实际效果

    当撰写这篇报告时，PA排行榜上暂列第二(考虑到这时9道题里我共有7个第一，这个第二的确是挺让我难以接受的)。