0. 题目描述
   
   给出长度为$n$的01串，寻找其中未出现的最短的01串。若有多个，取字典序小者
   
1. 所使用数据结构与算法的构思、原理和实现要点

    长度为$n$的01串的长度为$k(k\le n)$的子串有$n-k+1$个，所以它不能覆盖长度为$\lceil \log_2 n \rceil$的所有01串，从而得知答案的长度$\le \lceil \log_2 n \rceil$，在本题中这一数值是$24$。

    从而可以考查所有长度$\le 24$的01串是否在原串中出现过，假设现在只考虑长度为$l$的01串，注意$l\le 24\lt 32$，所以可以维护一个$32$位整数，扫描输入串的过程中让这个整数始终对应于一个长度为$l$的子串，具体方法是(并非最后的代码)
    ```
    x = (x << 1 | (ch == '1')) & ((1 << l)　-　1)
    ```

    但是分别对每个$l\le 24$都做这样的处理时间上无法接受。此时可注意到每一个在原串中出现过的长度为$l$的01串或者处在结尾，或者是一个长度为$l+1$的串的前缀，因此可以考虑先记录下所有长度$=24$的串的存在信息，在此基础上进行动态规划：
    $$exist[s]=exist[s+'0']||exist[s+'1']$$
    这里的exist数组是抽象的(实际上可看成散列表)，在实际代码中exist仍然是常规的数组，则转移方程为：
    $$exist[bit(s)]=exist[bit(s)<<1]||exist[bit(s)<<1|1]$$

    将字符串转化成二进制数字的时候需考虑前导0的问题，我的解决方案是：在每个长度上检查答案，因为若考虑完一个长度后，exist[bit(s)]为true，则必然存在s或s加一些前导0，那么也还是存在s；反之若为false,则s或任何s加一些前导0都不存在，那么也还是不存在s。于是在这个答案上查出来的答案的确是这个长度的真实答案(都被覆盖or字典序最小的未被覆盖的)，最终取长度最小的答案即可

    由于本题空间限制比较严格，这张表不是以$bool$数组的形式存在，而是利用了$64$位整数的每一个$bit$来标记一个值是否存在。后面会看到，这个方法不仅将空间使用减少到了$\frac{1}{8}$，经过合适的优化，也会让运行时间大大减少

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题

    本题运用了很多常数优化技巧，应该是我投入最多时间的一道PA，最后达到的速度也是十分理想的。这要感谢郑林楷同学反复的优化他的代码并超过我，才让我有了不断优化自己的代码的动力。

    上面提到的
    $$exist[bit(s)]=exist[bit(s)<<1]||exist[bit(s)<<1|1]$$
    存在很大优化空间，不难看出，为了推知一个区间内数字的存在情况，它所使用的信息也来自一个区间，具体来说，为了得知连续32个bit的存在信息，会用到连续的64个bit，也就是一个64位整数。我希望能把这个整数相邻的bit做或操作，再提取到一个32位整数中。事实上"x86intrin.h"中提供的_pext_u64函数完全符合需求，可惜评测机并不支持bmi2指令集(当场signal 4)，因此必须自己设计位运算。
    
    提取方法是
    ```cpp
    u32 or_adjacent_bit(u64 x)
    {
        x = (x | (x >> 1)) & 0x5555555555555555ull;
        x = (x | (x >> 1)) & 0x3333333333333333ull;
        x = (x | (x >> 2)) & 0x0F0F0F0F0F0F0F0Full;
        x = (x | (x >> 4)) & 0x00FF00FF00FF00FFull;
        x = (x | (x >> 8)) & 0x0000FFFF0000FFFFull;
        x = (x | (x >> 16)) & 0x00000000FFFFFFFFull;
        return x;
    }
    ```
    以下设64位整数从least significant bit到most significant bit记为0..63位

    第一行把相邻两bit或起来并且存到偶数位上，清除奇数位

    第二行，4bit一组，$bit_2$的结果放到$bit_1$上，清除其它位

    第二行，8bit一组，$bit_4,bit_5$的结果放到$bit_2,bit_3$上，清除其它位

    第三行，16bit一组，$bit_8,bit_9,bit_{10},bit_{11}$的结果放到$bit_4,bit_5,bit_6,bit_7$上，清除其它位

    ...

    最终就得到了存于least significant的32位的所需要的32位整数。

    虽然相比于基于_pext_u64的提取法还是多了很多运算：
    ```cpp
    u32 or_adjacent_bit(u64 x)
    {
        // only 3 cpu instructions!!!
        return _pext_u64(x, 0x5555555555555555ull) |
          _pext_u64(x, 0xAAAAAAAAAAAAAAAAull);
    }
    ```
    但是相比原版已经有了很大的提升：原版为了得到这个结果，需要64次内存访问，$32(<<1)+32*2(<<1|1)=96$次位运算，这只需要1次内存访问，18次位运算。

    读入的时候使用fread分段读取，在一段的基础上，可以利用位运算一次性提取出多个字符中'0'和'1'的存在情况。具体来说，因为字符只有'0''1'两种，二者二进制唯一的区别在最低位，'1'为1，'0'为0。先用**指针类型转化**获取到连续8个8为位整数对应的64位整数，用0x0101010101010101与之按位与，则每个byte若原为'0'则现为0，若原为'1'则现为1。再用和上面类似的办法把这8个byte合成成一个byte，其8位分别包含8个byte的01信息，即完成了对8个'0''1'的提取。之后可以手动循环展开，调用8次ins函数将8个新数插入bitset。注意指针类型转化得到的结果依赖于评测机的endian情况(当然它的确是little-endian的)。

    找空位的过程也可优化：先看该64位整数是否是-1ull，若不是则才有可能有空bit，这样减少了64倍的运算量
   
3. 时间和空间复杂度的估算
   
    第一遍扫描严格来说需要维护一个字长为$O(\log n)$的整数，从而这一过程需要花费$O(n\log n)$，但是本题$\log_2 n \le 24$，未超过我们认为的一次"基本操作"对应的字长，所以可以认为单次位运算耗时$O(1)$，整个扫描耗时$O(n)$

    在这一前提下，之后在表上扫描耗时为$O(2^{\log_2 n})=O(n)$

    从而总体时间复杂度为$O(n)$

    空间复杂度为$O(2^{\log_2 n}/8)=O(n)$

4. 实际效果
   
   我与郑林楷进行了旷日持久(两天)的卡常比赛，最终结果为我略胜一筹。其他同学的代码与我们的运行时间基本不在一个档次。
   