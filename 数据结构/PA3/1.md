0. 题目描述
   
   给出$n$个整数的序列和$m$次操作，每次操作为单点修改或者查询某一区间内的最大和子段

1. 所使用数据结构与算法的构思、原理和实现要点

    采用线段树解决

    每个节点维护４个字段:
    
    * $sum$ 表示区间数字之和
    * $lmax$ 表示以区间左端点开头的最大和子段之和
    * $rmax$ 表示以区间右端点开头的最大和子段之和
    * $max$ 表示整个区间最大和子段之和

    从两个孩子节点更新它们的父节点的方法是

    ```
    p.max = max(l.max, r.max, l.rmax + r.lmax);
    p.lmax = max(l.lmax, l.sum + r.lmax);
    p.rmax = max(r.rmax, l.rmax + r.sum);
    p.sum = l.sum + r.sum;
    ```
    从而可以套用标准的线段树的模型来解决

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    最开始使用了普通版的线段树(递归版的线段树)，耗时344ms，虽然完全足以通过此题但是仍不算满意。

    之后更换为zkw线段树(非递归线段树)，耗时有很大改进。

    zkw线段树是一棵满二叉树(对比：普通线段树只是真二叉树)，因此底层节点在物理上是连续的，可以快速地找到一个数据节点对应的下标，然后从此向上修改。

    查询时，将$[l,r]$的查询转化为$(l-1,r+1)$查询，先找到$l-1$和$r+1$各自对应的数据节点，然后一起向上更新。发现左端点当前是左节点或右端点当前是右节点时，用其兄弟来更新答案，这是因为其兄弟对应的区间被$(l-1,r+1)$完全包含。这一过程直到左节点和右节点互为兄弟时停止。

3. 时间和空间复杂度的估算

    显然$build$函数时间消耗为$O(n)$

    单次调用$query$和$update$函数都可以看成依次处理输入参数的每一个二进制位，时间消耗$O(\log n)$

    从而总时间复杂度$O(n+m \log n)$

    zkw线段树消耗空间为$2N$，其中$N=min\{2^i|2^i>n\}=O(n)$，从而空间复杂度为$O(n)$

4. 实际效果
   
   使用zkw线段树来代替普通线段树获得了200ms左右的加速。在此基础上，我观察到query函数中，左右分别向上统计答案两个节点各有一个字段对答案没有影响，于是将对这两个节点调用update函数改为了只维护各自有用的三个字段。这取得了12ms的加速(虽然看起来比较少，但这是从第二到第一的区别(在当时的排行榜下))。

   当撰写这篇报告时，PA排行榜上暂列第一。