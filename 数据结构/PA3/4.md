0. 题目描述
   
    给出三个长均为$n$的序列$a,b,c$，求第$k$大的$a_x+b_y+c_z$。不能访问序列元素，只能调用比较器得知$a_{x1}+b_{y1}+c_{z1}$和$a_{x2}+b_{y2}+c_{z2}$的大小关系


1. 所使用数据结构与算法的构思、原理和实现要点

    采用排序和堆解决

    首先对三个序列排序得到三个非降序列，排序也采用抽象的比较器，显然有

    $a_n\lt a_m\Leftrightarrow a_n+b_1+c_1\lt a_m+b_1+c_1$

    从而可以通过调用题目给出的比较器来对$a,b,c$三个序列排序。因为无法访问这个三个序列，所以就新建三个长度为$n$的序列，里面最初存储着$1,2,...,n$，在它们上面调用排序算法

    排好序之后用堆来解决。先考察简单情形：假设有两个长度为$n$的不降序列，取第$k$大的$a_x+b_y$。可以先写出$n^2$种组合情形，并按如下顺序排列

    * $a_1+b_1,a_1+b_2,...,a_1+b_n$
    * $a_2+b_1,a_2+b_2,...,a_2+b_n$
    * ...
    * $a_n+b_1,a_n+b_2,...,a_n+b_n$

    显然这样就形成了$n$个不降序列，于是问题便转化为了从$n$个不降序列中取第$k$大元素。注意这些序列事实上是抽象的序列，不用(时间和空间也不允许)真正构建出来

    求法是：维护一个$n$个元素的堆，每个元素代表一个序列的队头，每次取出堆中的最小值，将对应序列对头后移一位，重新加入堆，重复$k$次即可。

    现在考虑三个序列的情形，仍然可以采用这种方法：假设$b,c$可以组合出一个长度为$n^2$的有序序列$bc$，则现在的$n^3$种组合可以写成:

    * $a_1+bc_1,a_1+bc_2,...,a_1+bc_{n^2}$
    * $a_2+bc_1,a_2+bc_2,...,a_2+bc_{n^2}$
    * ...
    * $a_n+bc_1,a_n+bc_2,...,a_n+bc_{n^2}$

    然后按照上面的做法重复$k$次即可。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题

    排序采用归并排序，根据我的经验以及实验，对于这种比价操作比较昂贵的排序，归并排序的常数往往小于快速排序，这是因为归并排序的最坏比较次数仅仅为$n\log_2 n$，而快速排序的平均比较次数为$2n\ln n=1.386n\log_2 n$(事实上，归并排序的最坏比较次数$=$快速排序的最好比较次数)

    一个关于堆的常数优化技巧是：没有必要每次先弹出最大值再插入一个新值，这两步操作可以被替换为：将堆顶替换成将要插入的新值，然后只需一次下沉调整即可。

    另外，本题不需要建堆操作，这是因为我之前描述的两种长度为$n$的元素序列都自然是排好序的，而一个排好序的序列自然是一个小顶堆。
   
3. 时间和空间复杂度的估算
    
    排序耗时$O(3n\log n)=O(n\log n)$
    
    对于$bc$序列，最多求到$bc_k$，每次求一个$bc$元素耗时$O(\log n)$，求出来的$bc_i$存下来，下次需要的时候不用重复计算

    对于$a$序列和$bc$序列的组合，恰好求$k$次，每次耗时$O(\log n)$

    从而总时间复杂度为$O((n+k)\log n)$

    归并排序消耗$O(n)$空间，堆消耗$O(n)$空间，保存$bc_i$结果消耗$O(k)$空间，总空间复杂度为$O(n+k)$

4. 实际效果

    将快速排序换成归并排序取得了100ms左右的加速(当然了，相信绝大多数同学的快排也没有我的快)；将堆弹出最大值再插入一个新值替换为替换堆顶再一次下沉取得了200ms左右的加速，这都符合我的预计。

    当撰写这篇报告时，PA排行榜上暂列第一。