0. 题目描述
   
   给出一个序列，对于每个数求出序列与它的距离小于一个定值的，与它的异或值最大的值的下标。重复的数需要输出靠前的下标。

1. 所使用数据结构与算法的构思、原理和实现要点

    算法整体上使用了一个$trie$树。插入一个数是从高到低遍历它的所有$bit$(看成长度是$64$的字符串)，把它的下标存在叶子节点中。通过适当的插入和删除操作保证每次查询的时候树中只有限制范围内的元素。查询一个树是从高到低遍历它的所有$bit$，每次尽可能走与当前$bit$不同的方向，如果那个方向没有值就只能走另一个方向。根据异或的性质，这样就能找到与它的异或值最大的值。

    还有一个重要的细节是，重复的数需要输出靠前的下标。所以对于每个数必须存下它所有的下标。这种储存方式必须也只需支持：$O(1)$时间内访问头，插入头，删除尾。显然单向链表是一种合适的方式，相比于$stl$的$queue$(如果有的话)也更为高效。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    本题对空间的限制比较紧。如果限制很宽的话，一般来讲$trie$树要$n*64*2$个$int$来存储孩子节点下标，但是这些空间已经达到$256MB$(更不用说在节点中存储值了)，因而无法直接通过。

    注意到$trie$树有节点共用的性质，所以并不需要$64n$个节点才能存放$n$个值。容易发现，需要$64$个新节点的链至多有$2$条，需要$63$个新节点的链至多有$2$条，需要$62$个新节点的链至多有$4$条...。对于$x\in[1,63]$，需要$64-x$个新节点的链至多有$2^x$条。注意到$1+2+...+2^k=2^{k+1}-1$，而$2^{19}-1>500000\ge N$，所以实际上至多只需要$128+\sum_{i=1}^{18}{(64-i)2^i}=24641534$个节点，对应内存约$197.13MB$，可以顺利通过本题。

    除此之外，本题还需要对trie树进行删除操作，如果删除的节点不被回收的话，就会导致trie树的节点共用性质无法体现(因为此前建起来的结构可能又被消除)，导致内存超限。本题中采用了这样一种垃圾回收方法：当一个节点被确定删除时，将其父节点指向它的下标按位取反。插入节点时，分为该下标为0和该下标为负分别考虑。为0则新申请节点，为负则直接再取反回来即可。

    最后，本题实际上采用了四叉树的结构，它可以将内存访问的次数减少一半，常数因子更优，而所有的分析与二叉的情况大同小异，无需重复。
   
3. 时间和空间复杂度的估算

    时间复杂度$O(nlogU)$，其中$U$为值域，取值为$U=2^{64}$。

    空间复杂度见上述计算。定性的说，对于较小的$n$，空间复杂度为$O(nlogU)$，因为节点共用性质几乎体现不出来。对于充分大的$n$(事实上这才是大$O$记号的真正含义)，空间复杂度为$O(n)$，因为$trie$树必然被填满，只需要$O(n)$的空间来存储值即可。
   
