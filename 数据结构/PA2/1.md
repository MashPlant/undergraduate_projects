0. 题目描述
   
   给出n个整数，每次取出(不放回)两个相乘后放回原数组，整个过程的代价是所有的乘积的乘积。求最小代价。

1. 所使用数据结构与算法的构思、原理和实现要点

    不难证明为了使代价最小，每次应该选择数组中最小的两个数相乘。可以用堆来维护整个结构，但是容易看出这并非算法的时间瓶颈所在，所以实际上每次暴力寻找最小的两个数也没有任何问题(虽然我还是写了堆)。

    算法的瓶颈在于高精整数乘法。分析复杂度得知暴力的$O(n^2)$乘法也足以通过这道题，所以也没有必要使用fft或者分治乘之类的算法。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题。
   
3. 时间和空间复杂度的估算
   
    寻找最小值部分:
        
    * 单次整数比较耗时$O(len)$
    * 每次需比较$O(logn)$个整数

    整数乘法部分:

    * 整数乘法耗时$O(len1*len2)$

    下面分析$len$与$n$的关系:

    为分析简单起见假定所有整数相同，一开始对于整个数组都有$len=1$

    经过$n/2$次乘法后对于整个数组都有$len=2$

    再经过$n/4$次乘法后对于整个数组都有$len=4$
    
    ...

    假定n恰好是2的幂次，则共经过$n$次乘法后对于整个数组都有$len=n$

    考察第k层($n/2^k$次操作)：

    * 寻找整数耗时$2^klogn+2^klogn+...+2^klogn=O(nlogn)$
    * 生成整数耗时$(2^k)^2+(2^k)^2+...+(2^k)^2=O(2^kn)$
    * 更新答案耗时$2^k*((k-1)n+((k-1)n+2^k))+...+kn)=O(kn^2)$

    $k$取值于$[1, logn]$，对上面三项求和分别得到

    $O(nlog^2n),O(n^2),O(n^2log^2n)$

    显然整体的时间复杂度是$O(n^2log^2n)$(容易看出是否写堆对复杂度毫无影响)，对于$n\le2000$的数据规模要通过似乎有一定难度，但是考虑到时限是$2s$以及常系数事实上是小于1的(有好几个$1/2$相乘被忽略掉了)，通过此题实际上不成问题。