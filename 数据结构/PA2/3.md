0. 题目描述
   
   有向图，每个节点有$0/1$权值。

   第一问：求从节点$0$到节点$n-1$的路径，使得路径上经过的点权值和最小。

   第二问：求从节点$0$到节点$n-1$的路径，使得路径上经过的点权值和最大，重复经过一个节点权值只计算一次。

1. 所使用数据结构与算法的构思、原理和实现要点

    单链表存边。

    第一问：可以转化为最短路问题，又因为权值为$0/1$，实际上可以用$bfs$来解决。具体来说，循环这样一个过程：

    1. 拓展队列中的所有节点直到不能再拓展，只拓展点权为$0$的点。

    2. 计数器自增。

    3. 拓展队列中的所有节点直到不能再拓展，只拓展点权为$1$的点。

    直到访问到$n-1$节点，则当前计数器的值就是答案。

    显然上述过程可以保证：不存在任何一条路径，使得路径上经过的点权值和比得到的答案小，否则一定能提前找到这条路径。

    第二问：$scc$缩点，拓扑序$dp$。

    考虑本题性质，只需要对节点0调用$tarjan$算法即可。在此基础上，由于$tarjan$算法的性质，已经标记的$scc$是自然地符合拓扑序的逆序，因此无需再进行拓扑排序。

    $dp$的转移方程为

    $$ dp(i) = max_{j\in \Gamma^+(i)}(dp(j)) + sum(i) $$

    其中$sum(i)$表示第$i$个$scc$中硬币的个数

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题。

    一个卡常的技巧：定义了一个宏
    ```cpp
    #define foreach(head) for (int e = head; __builtin_prefetch(es + es[e].nxt, 0), e; e = es[e].nxt)
    ```
    这利用了编译器内置的函数__builtin_prefetch来预取一段内存。虽然这东西有点玄学，但是至少在此题上，它的确还是取得了一丁点的速度提升。
    
    这个做法是受到了linux代码中的遍历链表的宏
    ```
    #define list_for_each(pos, head) \
     for (pos = (head)->next; prefetch(pos->next), pos != (head); \
             pos = pos->next)
    ```
    的启发。
    
3. 时间和空间复杂度的估算

    时间复杂度和空间复杂度均为$O(n+m)$。
   
