0. 题目描述
   
   利用一个能够给出三个整数的最大值和最小值的比较器(使用次数有限)来排序一组整数。

1. 所使用数据结构与算法的构思、原理和实现要点

    采用四路归并排序。

    先考虑平凡情形。序列中只有0个或1个元素时，已经排好序，立即返回。序列中由2个或3个元素时，显然只使用一次比较器足够排好序。

    非平凡的情况下。将序列分为四段递归调用算法。合并过程为：首先任选三个序列的队首进行一次比较，那么本次比较得到的最大值一定不可能是这四个序列的队首的最小值。据此，可以选择其余三个元素进行比较，得到队首的最小值，这次比较又会得到一个最大值，它又不可能是最小值，又可以给下一次选择提供依据。

    如此，恰好进行一次比较即可以选择出一个新的最小值。当四个序列退化为三个或两个或一个时，显然仍然恰好进行一次比较即可以选择出一个新的最小值。注意到最后至少还剩下一个元素无需比较，填上了最开始多使用的一次，也就是说最多n次调用比较器，可以把这4个序列归并成一个有序序列。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有问题。
   
3. 时间和空间复杂度的估算
   
    消耗$O(n)$的额外空间。

    时间复杂度和比较器使用次数显然都是$O(nlogn)$，但是比较器使用次数的数量级并没有太大意义，必须分析出一个较为精确的上界。

    这里给出一个比较器使用次数的上界。
    
    $$T(n)=\begin{cases}
        0 & n = 0 \lor n = 1
        \\
        1 & n = 2 \lor n = 3
        \\
        3T(\lfloor n/4\rfloor)+T(n-3\lfloor n/4\rfloor)+n & else
    \end{cases}$$

    这个式子基本可以有上面的论述得到，除了一个小细节：取$3T(\lfloor n/4\rfloor)+T(n-3\lfloor n/4\rfloor)$而非$4T(n/4)$，因为这才是计算过程中的真正过程。

    计算可以得到

    $T(10)=17$

    $T(100)=328$

    $T(1000)=4832$

    $T(10000)=64288$

    $T(100000)=820032$

    $T(1000000)=9755392$

    显然均是符合题目要求的。事实上可以分析得到$T(n)\approx nlog_4n$，这差不多也是题目限制的增长趋势。