0. 题目描述
   
   给定n对整数，求出每对整数的乘积。1 ≤ n ≤ 500，0 ≤ 整数 < 10^5000

1. 所使用数据结构与算法的构思、原理和实现要点

    并没有使用什么特别的数据结构，简单的利用数组来进行整数的存储。

    整数乘法方面，采用了Karatsuba算法，即分治乘法。算法的核心在于将整数分成高低两个部分，分别进行乘法再将结果合并。下面是简单的推导，设x与y是两个位数相同的长整数：
    
    $x=x_{1}B^{m}+x_{0}$; $y=y_{1}B^{m}+y_{0}$
    
    $xy=(x_{1}B^{m}+x_{0})(y_{1}B^{m}+y_{0})=x_{1}y_{1}B^{2m}+(x_{1}y_{0}+x_{0}y_{1})B^{m}+x_{0}y_{0}$

    其中：

    $x_{1}y_{0}+x_{0}y_{1}=(x_{1}+x_{0})(y_{1}+y_{0})-x_{1}y_{1}-x_{0}y_{0}$
    
    于是问题转换为计算$(x_{1}+x_{0})(y_{1}+y_{0})$，$x_{1}y_{1}$和$x_{0}y_{0}$，再进行若干次加减法。

    算法的复杂度为：

    $T(n)=3T(\lceil n/2\rceil )+O(n)$

    $T(1)=O(1)$

    根据主定理可以得到$T(n)=O(n^{log_{2}3})\approx O(n^{1.585})$

    算法的实现：需要写一个暴力乘法作为递归的终止情况，还需要实现整数的加法和减法，整体代码复杂程度并没有比fft减少多少。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    一直有几个测试点无法通过，后来发现是因为上次的结果没有清零。通过生成多组一个较长的整数乘较短的整数的数据发现了问题。
    
    参考了https://en.wikipedia.org/wiki/Karatsuba_algorithm 和 python源码中整数乘法的实现。
   
3. 时间和空间复杂度的估算
   
   时间复杂度$O(nLen^{log_{2}3})$

    额外空间$O(Len)$

    其中n为数据组数，Len为整数位数。

4. 实测效果

    编写这篇report时在PA上时间排名第八。可见算法效率较高。但是我自己仍不太满意，还有可以提升的地方，比如特判两个整数位数差距很大时改用暴力乘法也许会比补0之后用Karatsuba算法效率更高。