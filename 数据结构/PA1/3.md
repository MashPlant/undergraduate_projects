0. 题目描述
   
    通过插入字符和删除字符的方式将一个串修改为另一个串，修改次数不超过k，否则输出-1。

1. 所使用数据结构与算法的构思、原理和实现要点

    容易发现所求答案等于$m+n-2*LCS$，其中LCS是两个串的最长公共子序列长度。但是朴素地计算最长公共子序列会花费$O(nm)$的时间，在这道题里是不可接受的。需要利用修改次数不超过k来进行限制。

    我的实现参考了论文[An O(ND) Difference Algorithm and Its Variations](http://www.xmailserver.org/diff2.pdf)，在这道题目中也就是$O(nk)$，可以顺利通过此题。

    定义：

    Edit Graphs(编辑图)：也就是一般用来演示LCS的那张图。这是一张n*m的网格图，从坐标(0, 0)向第一象限前进，直到走到(n, m)。每次可以走水平线(代表忽略了x轴上的一个字符)，竖直线(代表忽略了y轴上的一个字符)，对角线(代表x轴上的一个字符与y轴上的一个字符匹配)。显然水平线和竖直线的条数之和即是对字符串的修改次数。

    D-path：从(0, 0)开始，水平线和竖直线的条数之和恰好为D的一条路径。

    diagonal k：坐标差$x-y=k$的一条对角线。

    性质：

    一个D-path一定由最后一段连续的对角线(可能条数为0)和一个水平/竖直线和一个(D-1)-path组成

    一个D-path只可能中止在diagonal k, k $\in \{-D, -D+2, ... ,D-2,D\}$上

    我们的目标是，对于每个D和k，寻找"走的最远"的中止在diagonal k上的D-path。如果它到达了(n, m)，证明匹配已经完成。第一个这样的D即是最小修改次数。

    利用反证法不难得到，一个"走的最远"的中止在diagonal k上的D-path只可能由一个"走的最远"的中止在diagonal (k-1)上的(D-1)-path或者"走的最远"的中止在diagonal (k+1)上的(D-1)-path按照上面的方法转移而来。

    这样便得到了一个动态规划的算法。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料
    
    没有遇到问题。

    参考资料：[An O(ND) Difference Algorithm and Its Variations](http://www.xmailserver.org/diff2.pdf)
   
3. 时间和空间复杂度的估算
   
   时间复杂度$O(nk)$

   额外空间$O(n)$

4. 实测效果

    编写这篇report时在PA上时间排名第一，比第二名的用时少了一个数量级。

    虽然最坏情况下算法的时间复杂度是$O(nk)$，但实际上算法运行的相当快速。从代码中大致可以看出，对于很相似或者很不相似的串算法均能快速解决。论文中也进行了分析，指出算法的期望用时是$O(N+D^2)$。
